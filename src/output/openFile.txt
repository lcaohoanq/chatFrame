# AcessToken Middleware d√†nh cho logout# t·∫°o d·ª±ng ch·ª©c nƒÉng logout- `logout` ph·∫£i l√† method `post` v√¨  - `post` l√† th√¥ng qua m·ªôt n√∫t nh·∫•n (c√≥ th·ªÉ d√πng get, nh∆∞ng get th√¨ ta l·∫•y g√¨ v·ª?? ta ch·ªâ c·∫ßn b√°o l√™n cho server th√¥i l√† ƒë∆∞·ª£c r·ªìi)  - `get` th√¨ th∆∞·ª?ng th√¥ng qua link ƒë·ªÉ l·∫•y d·ªØ li·ªáu, v·∫≠y th√¨ ng∆∞·ª?i d√πng s·∫Ω d√πng 1 url ƒë·ªÉ logout, tr√¥ng r·∫•t k·ª≥ c·ª•c  - ngo√†i ra ta c√≤n mong mu·ªën ng∆∞·ª?i d√πng ph·∫£i g·ªØi l√™n cho m√¨nh m·ªôt `rft`  - v·∫≠y n√™n ta t·∫°o logout v·ªõi method `post` v·ªõi 1    header: Authorization: Bear access_token (d√πng ƒë·ªÉ bi·∫øt account n√†o mu·ªën logout)    v√† body:{refresh_token} (d√πng ƒë·ªÉ x√≥a token trong collection refresh_tokens)- v·∫≠y ƒë·ªÉ logout ng∆∞·ª?i d√πng s·∫Ω truy·ª?n l√™n access_token v√† refresh_token, g·ªØi qua route l√† `users/logout` v√† x·ª≠ l√Ω `access_token` b·∫±ng 1 middleware nh∆∞ sau:  - validate access_token (ki·ªÉm tra client c√≥ g·ªØi l√™n kh√¥ng, xem c√≥ ƒë√∫ng kh√¥ng)  - g√°n decoded_authorization(json c·ªßa payload: th√¥ng tin ng∆∞·ª?i g·ªØi - user_id) v√†o req : ƒë·ªÉ sau n√†y m√¨nh c·∫ßn bi·∫øt ai ƒë√£ g·ªØi req th√¨ m√¨nh c√≥ x√†i- x·ª≠ l√Ω `refresh_token` middleware nh∆∞ sau:  - validate refresh_token(c√≥ g·ªØi l√™n hay k, h·∫øt th·ª?i gian kh√¥ng, c√≥ trong database hay kh√¥ng)  - g√°n decoded_authorization v√† req- middleware x·ª≠ l√Ω x√≥a refresh_token- tr·∫£ v·ª? message logout th√†nh c√¥ng- tham kh·∫£o lu·ªìng x·ª≠ l√Ω logout ·ªü ƒë√¢y<iframe style="border: 1px solid rgba(0, 0, 0, 0.1);" width="800" height="450" src="https://www.figma.com/embed?embed_host=share&url=https%3A%2F%2Fwww.figma.com%2Ffile%2FBeECRO014VsTDbyiWkgUyy%2FUntitled%3Ftype%3Ddesign%26node-id%3D0%253A1%26mode%3Ddesign%26t%3DjFTd64xLgUqRUEYh-1" allowfullscreen></iframe># b·∫Øt ƒë·∫ßu x·ª≠ l√Ω- v√†o route v√† th√™m `logout`  ```ts  /*    des: lougout    path: /users/logout    method: POST    Header: {Authorization: Bearer <access_token>}    body: {refresh_token: string}    */  usersRouter.post("/logout"); //ta s·∫Ω th√™m middleware sau  ```- th√™m trong `message.ts` c√°c th√¥ng b√°o l·ªói  ```ts  ACCESS_TOKEN_IS_REQUIRED: 'Access token is required',  REFRESH_TOKEN_IS_REQUIRED: 'Refresh token is required'  ```- gi∆° ta t·∫°o middleware ƒë·∫ßu ti·ª?n gi√∫p validate accesstoken t√™n l√† `accessTokenValidator`  v√† accessToken ch·ªâ n·∫±m ·ªü Header n√™n ta s·∫Ω cho checkSchema v√†o ƒë√∫ng `header` m√† th√¥i  ƒë·ªìng th·ª?i c≈©ng fix l·∫°i c√°c validator tr√™n ch·ªâ check `body` m√† th√¥i ngo√†i ra `checkSchema` c√≤n c√≥ th·ªÉ check ri√™ng c√°c ph·∫ßn kh√°c c·ªßa req nh∆∞ `'body' | 'cookies' | 'headers' | 'params' | 'query'`  ```ts    export const loginValidator = validate(        checkSchema(            {            ...            },            ['body']        )    )    export const registerValidator = validate(        checkSchema(            {...            },            ['body']        )    )    export const accessTokenValidator = validate(        checkSchema(            {            Authorization: {                notEmpty: {                //ki·ªÉm tra c√≥ g·ªØi l√™n kh√¥ng                errorMessage: USERS_MESSAGES.ACCESS_TOKEN_IS_REQUIRED                },                custom: {                //value l√† gi√° tr·ªã c·ªßa Authorization, req l√† req c·ªßa client g·ªØi l√™n server                options: async (value: string, { req }) => {                    //value c·ªßa Authorization l√† chu·ªói "Bearer <access_token>"                    //ta s·∫Ω t√°ch chu·ªói ƒë√≥ ra ƒë·ªÉ l·∫•y access_token b·∫±ng c√°ch split                    const access_token = value.split(' ')[1]                    //n·∫øu n√≥ c√≥ truy·ª?n l√™n , m√† l·∫°i l√† chu·ªói r·ªóng th√¨ ta s·∫Ω throw error                    if (!access_token) {                        //throw new Error(USERS_MESSAGES.ACCESS_TOKEN_IS_REQUIRED)  //n√†y tr·∫£ ra 422(k hay)                       // th√¨ k hay, ta ph·∫£i tr·∫£ ra 401(UNAUTHORIZED)                        throw new ErrorWithStatus({                            message: USERS_MESSAGES.ACCESS_TOKEN_IS_REQUIRED,                            status: HTTP_STATUS.UNAUTHORIZED                        })                    }                    //ki·ªÉm tra xem access_token c√≥ h·ª£p l·ªá hay kh√¥ng                    const user = await databaseService.users.findOne({ access_token })                    //t·∫°m th·ª?i d·ª´ng ƒë√¢y 1 t√Ω, ta c·∫ßn ph·∫£i vi·∫øt h√†m ƒë·ªÉ verify access_token b·∫±ng jwt npm                }                }            }            },            ['headers']        )    )  ```  - l√†m verify cho accesstoken b·∫±ng h√†m c√≥ s·∫µn c·ªßa [jwt npm](https://www.npmjs.com/package/jsonwebtoken) nh∆∞ng ta s·∫Ω chuy·ªÉn n√≥ th√†nh `promise` cho ph√π h·ª£p v·ªõi vi·ªác x·ª≠ l√Ω l·ªói d·ªìn v·ª? 1 `error handler`    ![Alt text](image-86.png)  - v√†o `jwt.ts` code th√™m `verifyToken`    ```ts    export const verifyToken = ({      token,      secretOrPublicKey = process.env.JWT_SECRET as string,    }: {      token: string;      secretOrPublicKey?: string;    }) => {      //tr·∫£ v·ª? JwtPayload(th√¥ng tin ng∆∞·ª?i g·ªØi req) n·∫øu token h·ª£p l·ªá      return new Promise<jwt.JwtPayload>((resolve, reject) => {        //method n√†y s·∫Ω verify token, n·∫øu token h·ª£p l·ªá th√¨ n√≥ s·∫Ω tr·∫£ v·ª? payload        //n·∫øu token kh√¥ng h·ª£p l·ªá th√¨ n√≥ s·∫Ω throw error        //secretOrPublicKey d√πng ƒë·ªÉ verify token        //n·∫øu token ƒë∆∞·ª£c t·∫°o ra b·∫±ng secret|PublicKey th√¨ ta d√πng secret|PublicKey key ƒë·ªÉ verify        //t·ª´ ƒë√≥ bi·∫øt r·∫±ng access_token ƒë∆∞·ª£c t·∫°o b·ªüi ch√≠nh server        jwt.verify(token, secretOrPublicKey, (error, decoded) => {          if (error) throw reject(error);          resolve(decoded as jwt.JwtPayload);        });      });    };    ```    quay l·∫°i code ti·∫øp `accessTokenValidator` ƒëo·∫°n `options` v√† d√πng `verifyToken` v·ª´a vi·∫øt    ƒë·ªìng th·ª?i x·ª≠ l√Ω l·ªói ƒë·ªÉ l·ªói trong ƒë·∫πp, v√† t∆∞·ª?ng minh h∆°n    ```ts     export const accessTokenValidator = validate(        checkSchema(            {                Authorization: {                    options: async (value: string, { req }) => {                        ...                        //n·∫øu n√≥ c√≥ truy·ª?n l√™n , m√† l·∫°i l√† chu·ªói r·ªóng th√¨ ta s·∫Ω throw error                        if (!access_token) {                            //throw new Error(USERS_MESSAGES.ACCESS_TOKEN_IS_REQUIRED)                            //n√†y tr·∫£ ra 422(k kh·ª£p validator) th√¨ k hay, ta ph·∫£i tr·∫£ ra 401(UNAUTHORIZED)                            throw new ErrorWithStatus({                                message: USERS_MESSAGES.ACCESS_TOKEN_IS_REQUIRED,                                status: HTTP_STATUS.UNAUTHORIZED                            })                        }                        //ki·ªÉm tra xem access_token c√≥ h·ª£p l·ªá hay kh√¥ng                        //·ªü ƒë√¢y m√¨nh trycath ƒë·ªÉ t·∫°o ra l·ªói c√≥ status kh√°c 422, n·∫øu k th√¨ khi ph√°t sinh l·ªói s·∫Ω l√† 422                        try {                          const decoded_authorization = await verifyToken({ token: access_token })                          //n·∫øu kh√¥ng c√≥ l·ªói th√¨ ta l∆∞u decoded_authorization v√†o req ƒë·ªÉ khi n√†o mu·ªën bi·∫øt ai g·ªØi req th√¨ d√πng                          req.decoded_authorization = decoded_authorization                        } catch (error) {                          throw new ErrorWithStatus({                            //(error as JsonWebTokenError).message s·∫Ω cho chu·ªói `accesstoken invalid`, kh√¥ng ƒë·∫πp l·∫Øm                            //ta s·∫Ω vi·∫øt h√≥a ch·ªØ ƒë·∫ßu ti√™n b·∫±ng .capitalize() c·ªßa lodash                            message: capitalize((error as JsonWebTokenError).message),                            status: HTTP_STATUS.UNAUTHORIZED                          })                        }                        return true //n·∫øu kh√¥ng c√≥ l·ªói th√¨ tr·∫£ v·ª? true                    }                }            }        )    ```    test th·ª≠    ```ts    //b√™n route    usersRouter.post(      "/logout",      accessTokenValidator,      wrapAsync((req, res) => {        res.json({ message: "Logout success" });      })    );    ```    login xong l·∫•y `ac` v√† `rf`    ![Alt text](image-87.png)    t·∫°o request `logout post` v√† c√†i th√™m ac v√†o    th√™m Authorization cho header    ![Alt text](image-88.png)    th√™m refresh cho body, nh∆∞ng ch∆∞a code n√™n b·ª? tr·ªëng    ![Alt text](image-89.png)    test    ![Alt text](image-90.png)    v√≠ d·ª• truy·ª?n sai authorization - thi·∫øu bearer    ![Alt text](image-91.png)# refresh token middleware v√† logout logic- khi m√† `logout`, `client` ph·∫£i truy·ª?n l√™n `access_token` th√¥ng qua `headers` ƒë·ªÉ m√¨nh bi·∫øt `client` l√† ai- ngo√†i ra c√≤n ph·∫£i truy·ª?n l√™n `refresh_token` ƒë·ªÉ m√¨nh ti·∫øn h√†nh x√≥a tr√™n `database` v·∫≠y n√™n ta ph·∫£i ki·ªÉm tra `refresh_token` l√† th·∫≠t hay gi·∫£- ti·∫øn h√†nh l√†m `refreshToken middleware`  - trong file `messages.ts` th√™m `REFRESH_TOKEN_IS_INVALID: 'Refresh token is invalid'`  - trong `users.middlewares.ts` t·∫°o middleware `refreshTokenValidator` c√≥ n·ªôi dung validator nh∆∞ sau    ```ts    export const refreshTokenValidator = validate(      checkSchema(        {          refresh_token: {            notEmpty: {              errorMessage: USERS_MESSAGES.REFRESH_TOKEN_IS_REQUIRED,            },            custom: {              options: async (value: string, { req }) => {                try {                  const decoded_refresh_token = await verifyToken({                    token: value,                  });                  //verify gi√° tr·ªã c·ªßa refresh_token xem c√≥ h·ª£p l·ªá hay kh√¥ng, qu√° tr√¨nh n√†y c√≥ th·ªÉ ph√°t sinh l·ªói                  //n·∫øu kh√¥ng c√≥ l·ªói th√¨ l∆∞u decoded_refresh_token v√†o req ƒë·ªÉ khi n√†o mu·ªën bi·∫øt ai g·ªØi req th√¨ d√πng                  //decoded_refresh_token c√≥ d·∫°ng nh∆∞ sau                  //{                  //  user_id: '64e3c037241604ad6184726c',                  //  token_type: 1,                  //  iat: 1693883172,                  //  exp: 1702523172                  //}                  req.decoded_refresh_token = decoded_refresh_token;                } catch (error) {                  throw new ErrorWithStatus({                    message: USERS_MESSAGES.REFRESH_TOKEN_IS_INVALID,                    status: HTTP_STATUS.UNAUTHORIZED, //401                  });                }                console.log(req.decoded_refresh_token); //xem xong ,test xong t·∫Øt                return true; //n·∫øu kh√¥ng c√≥ l·ªói th√¨ tr·∫£ v·ª? true              },            },          },        },        ["body"]      )    );    ```  - ta v√†o `users.routes.ts` th√™m middleware n√†y v√†o 1 route n√†o ƒë√≥ ƒë·ªÉ test cho ti·ªán, c·ª• th·ªÉ l√† b·ª? v√†o logout lu√¥n ƒë·ªÉ test    ```ts    usersRouter.post(      "/logout",      accessTokenValidator,      refreshTokenValidator,      wrapAsync((req, res) => {        res.json({ message: "Logout success" });      })    );    ```  - ta test th·ª≠:    - 1. ta th·ª≠ logout v√† s·∫Ω b·ªã jwt h·∫øt h·∫°n         ![Alt text](image-92.png)    - 2. ta ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ c√≥ `ac` v√† `rf`         ![Alt text](image-93.png)    - 3. copy `ac` b·ª? v√†o logout>Auth>BearerToken, t·∫Øt bi·∫øn Authorization khi m√¨nh d√πng Auth r·ªìi         ![Alt text](image-94.png)         ![Alt text](image-96.png)    - 4. copy `rf` b·ª? v√†o logout>body,         n·∫øu b·ª? tr·ªëng `rf` ta s·∫Ω c√≥ l·ªói `"Refresh token is required"` 422         n·∫øu sai th√¨ ta s·∫Ω c√≥ `"Refresh token is invalid"` 401         ![Alt text](image-95.png)  - theo m√¥ h√¨nh th√¨ sau khi check `rf` t·ªìn t·∫°i trong request, verify xong, th√¨ ki·ªÉm tra n√≥ c√≥ t·ªìn t·∫°i trong db hay kh√¥ng, ch·ª© kh√¥ng ph·∫£i l√† g√°n v√†o req li·ª?n    ![Alt text](image-98.png)  - n√™n gi·ª? ta ti·∫øn h√†nh code ti·∫øp middleware`refreshTokenValidator` trong `users.middlewares.ts`, c·ª• th·ªÉ l√† ngo√†i vi·ªác verify, ta ki·ªÉm tra `rf` n√†y c√≥ trong db hay kh√¥ng    - t·∫°o `message.ts` l√† `USED_REFRESH_TOKEN_OR_NOT_EXIST: 'Used refresh token or not exist',`    - `refreshTokenValidator` fix th√†nh      ```ts      export const refreshTokenValidator = validate(        checkSchema(          {            ...            custom: {              options: async (value: string, { req }) => {                try {                  // const decoded_refresh_token = await verifyToken({ token: value }) //kh√¥ng d√πng n·ªØa                  //thay th√†nh: v·ª´a verify v·ª´a t√¨m trong db xem c√≥ refresh_token n√†y kh√¥ng                  const [decoded_refresh_token, refresh_token] = await Promise.all([                    verifyToken({ token: value }),                    databaseService.refreshTokens.findOne({ token: value })                  ])                  //n·∫øu kh√¥ng c√≥ refresh_token n√†y trong db th√¨ ta s·∫Ω throw error                  if (refresh_token === null) {                    throw new ErrorWithStatus({                      message: USERS_MESSAGES.USED_REFRESH_TOKEN_OR_NOT_EXIST,                      status: HTTP_STATUS.UNAUTHORIZED //401                    })                  }                  //n·∫øu c√≥ th√¨ ta l∆∞u decoded_refresh_token v√†o req ƒë·ªÉ khi n√†o mu·ªën bi·∫øt ai g·ªØi req th√¨ d√πng                  req.decoded_refresh_token = decoded_refresh_token                } catch (error) {                  //trong middleware n√†y ta throw ƒë·ªÉ l·ªói v·ª? default error handler x·ª≠ l√Ω                  if (error instanceof JsonWebTokenError) {                    //n·∫øu l·ªói thu·ªôc verify th√¨ ta s·∫Ω tr·∫£ v·ª? l·ªói n√†y                    throw new ErrorWithStatus({                      message: capitalize((error as JsonWebTokenError).message),                      //ƒë·ªÉ b√°o l·ªói t∆∞·ª?ng minh h∆°n                      status: HTTP_STATUS.UNAUTHORIZED //401                    })                  }                  //c√≤n n·∫øu kh√¥ng ph·∫£i th√¨ ta s·∫Ω tr·∫£ v·ª? l·ªói do ta throw ·ªü tr√™n try                  throw error // n√†y l√† l·ªói ƒë√£ t·∫°o tr√™n try                  //vi·ªác ph√¢n bi·ªát l·ªói n√†y gi√∫p server tr·∫£ ra l·ªói t∆∞·ª?ng m√¨nh v√† c·ª• th·ªÉ h∆°n              }              return true //n·∫øu kh√¥ng c√≥ l·ªói th√¨ tr·∫£ v·ª? true            }            ...          }      )      ```  - test l·∫°i code b·∫±ng post man xem c√≥ ·ªïn kh√¥ng ?## l√†m logout logic- trong `route logout` ta ch∆∞a c√≥ `logoutController`, ch·ªâ l√† 1 c√°i h√†m res.json ƒë∆°n ƒëi·ªáu, ch∆∞a l√†m g√¨ c·∫£  ```ts  usersRouter.post(    "/logout",    accessTokenValidator,    refreshTokenValidator,    wrapAsync((req, res) => {      res.json({ message: "Logout success" });    })  );  ```  t√Ω ta s·∫Ω t·∫°o `logoutController` n√™n gi·ª? ta thay tr∆∞·ªõc cho route  ```ts  usersRouter.post(    "/logout",    accessTokenValidator,    refreshTokenValidator,    wrapAsync(logoutController)  );  ```- gi·ª? ta s·∫Ω v√†o `users.controllers.ts` t·∫°o `logoutController` nh∆∞ng tr∆∞·ªõc ti√™n ta nh·ªõ r·∫±ng ƒë·ªÉ logout ta s·∫Ω truy c·∫≠p v√†o database v√† x√≥a refresh_token ƒëi, v√† khi x√≥a xong th√¨ ta s·∫Ω c√≥ message th√¥ng b√°o logout th√†nh c√¥ng n√™n  - 1. `message.ts` th√™m `LOGOUT_SUCCESS: 'Logout success'`  - 2. `users.service.ts` th√™m h√†m logout - nhi·ªám v·ª• l√† v√†o db t√¨m v√† x√≥a refresh_token ƒëc ch·ªâ ƒë·ªãnh, return ra th√¥ng b√°o LOGOUT_SUCCESS    ```ts      async logout(refresh_token: string) {        await databaseService.refreshTokens.deleteOne({ token: refresh_token })        return {          message: USERS_MESSAGES.LOGOUT_SUCCESS        }      }    ```  - 3. `logoutController` l·∫•y `rf` t·ª´ `req.body` do client g·ªØi l√™n       g·ª?i usersService.logout(rf) ƒë·ªÉ t√¨m v√† x√≥a    ```ts    //route n√†y nh·∫≠n v√†o refresh_token v√† access_token    export const logoutController = async (req: Request, res: Response) => {      const { refresh_token } = req.body;      const result = await usersService.logout(refresh_token); //h√†m tr·∫£ ra chu·ªói b√°o logout th√†nh c√¥ng      return res.json(result);    };    ```# tinh ch·ªânh hi·ªáu nƒÉng 1 t√Ω ƒë·ªÉ flow code t·ªët h∆°n- ·ªü trong `logoutController````tsexport const logoutController = async (req: Request, res: Response) => {  const { refresh_token } = req.body  req. //th√¨ n√≥ kh√¥ng nh·∫Øc code ta l√† trong req c√≥ g√¨  ...}```- ƒë√≥ l√† v√¨ req c·ªßa ta ch·ªâ ƒëang l√† any m√† th√¥i, ta s·∫Ω ƒë·ªãnh d·∫°ng cho req c·ªßa m√¨nh, ƒë·ªÉ sau n√†y n√≥ s·∫Ω nh·∫Øc code cho ta t·ªët h∆°n- `decoded_refresh_token` v√† `decoded_authorization` l√† `JwtPayload`  ![Alt text](image-99.png)  v√† ·ªü ƒë√¢y n√≥ lu√¥n thi·∫øu `user_id` v√† `token_type`- n√™n ta s·∫Ω t·∫°o interface m·ªõi t√™n `TokenPayload` k·∫ø th·ª´a `JWTPayload` v√† cho `decoded_refresh_token` v√† `decoded_authorization` t·∫°o ra t·ª´ n√≥  - ta v√†o file ƒë·ªãnh d·∫°ng `req` l√† `User.requests.ts` v√† th√™m interface    ```ts    //ƒë·ªãnh nghƒ©a req cho th·∫±ng logoutController    export interface LogoutReqBody {      refresh_token: string;    }    export interface TokenPayload extends JwtPayload {      user_id: string;      token_type: TokenType;    }    ```  - ƒë·ªãnh nghƒ©a `Request` c√≥ g√¨ b·∫±ng `type.d.ts`    ```ts    declare module "express" {      interface Request {        user?: User;        decoded_authorization?: TokenPayload;        decoded_refresh_token?: TokenPayload;      }    }    ```  - ·ªü `jwt.ts` cho khi `verify` xong th√¨ tr·∫£ ra `decode` c√≥ d·∫°ng l√† `TokenPayload`    ```ts    export const verifyToken = ({    ...    }) => {      return new Promise<TokenPayload>((resolve, reject) => {//TokenPayload        jwt.verify(token, secretOrPublicKey, (error, decoded) => {          if (error) throw reject(error)          resolve(decoded as TokenPayload)//ƒë·ªïi th√†nh TokenPayload        })      })    }    ```  - l√∫c n√†y ·ªü `user.middlewares.ts` ta c√≥ th·ªÉ vi·∫øt th√†nh    ```ts    //trong accessTokenValidator    //req.decoded_authorization = decoded_authorization //b·ª? v√† thay th√†nh    (req as Request).decoded_authorization = decoded_authorization;    //t∆∞∆°ng t·ª± v·ªõi  refreshTokenValidator    //req.decoded_refresh_token = decoded_refresh_token //b·ª? v√† thay th√†nh    (req as Request).decoded_refresh_token = decoded_refresh_token;    ```    ta s·∫Ω fix l·∫°i 1 t√Ω logoutController v√† test l·∫°i s·∫Ω    th·∫•y r·∫±ng l√∫c n√†y ta s·∫Ω ƒëc nh·∫Øc code    ```ts    export const logoutController = async (req: Request<ParamsDictionary, any, LogoutReqBody>, res: Response) => {      const { refresh_token } = req.body. //gi·∫£ x·ª≠ c√≥ ch·∫•m n·ªØa th√¨ n√≥ s·∫Ω hi·ªán refresh_token      req. //l√∫c n√†y ·ªü ƒë√¢y c≈©ng s·∫Ω nh·∫Øc code cho ta      ...    }    ```- trong `.env` ta th·∫•y r·∫±ng ta ch·ªâ d√πng 1 JWT_SECRET ƒë·ªÉ sign v√† verify cho c·∫£ access, refresh v√† sau n√†y l√† mail  ƒëi·ª?u n√†y v√¥ h√¨nh chung l√†m cho code c·ªßa ta k b·∫£o m·∫≠t v√† ch·∫∑c ch·∫Ω, n√™n gi·ª? ta s·∫Ω t·∫°o ri√™ng cho ch√∫ng 3 c√°i token kh√°c nhau lu√¥n  ```    // JWT_SECRET = '123!@#' thay th√†nh    JWT_SECRET_ACCESS_TOKEN = '123!@#1'    JWT_SECRET_REFRESH_TOKEN = '123!@#2'    JWT_SECRET_EMAIL_VERIFY_TOKEN = '123!@#2'  ```  - code l·∫°i `signToken` v√† `verifyToken` trong `jwt.ts`  ```ts  export const signToken = ({    payload,    //privateKey = process.env.JWT_SECRET as string,    privateKey,    options = { algorithm: 'HS256' }  }: {  payload: object | string | Buffer  privateKey: string // b·ª? ? ƒë·ªÉ √©p truy·ª?n v√†o  //t∆∞∆°ng t·ª± v·ªõi verifyToken  export const verifyToken = ({    token,    //secretOrPublicKey = process.env.JWT_SECRET as string    secretOrPublicKey,  }: {    token: string    secretOrPublicKey: string //b·ª? ? ƒë·ªÉ √©p truy·ª?n v√†o  ```  - ta l√†m v·∫≠y th√¨ c√°ch x√†i verify ƒë√£ thay ƒë·ªïi, n√™n n√≥ s·∫Ω l·ªói ·ªü nh·ªØng ch·ªó d√πng signToken v√† verifyToken    - 1.  `users.services.ts > UsersService `    ```ts    class UsersService {      private signAccessToken(user_id: string) {        return signToken({          payload: { user_id, token_type: TokenType.AccessToken },          options: { expiresIn: process.env.ACCESS_TOKEN_EXPIRE_IN },          privateKey: process.env.JWT_SECRET_ACCESS_TOKEN as string //th√™m        })      }      private signRefreshToken(user_id: string) {        return signToken({          payload: { user_id, token_type: TokenType.RefreshToken },          options: { expiresIn: process.env.REFRESH_TOKEN_EXPIRE_IN },          privateKey: process.env.JWT_SECRET_REFRESH_TOKEN as string //th√™m        })      }      ...    ```    - 2.trong `users.middlewares.ts`    ```ts    //trong accessTokenValidator ,ƒëo·∫°n    // const decoded_authorization = await verifyToken({ token: access_token }) ƒë·ªïi th√†nh    const decoded_authorization = await verifyToken({      token: access_token,      secretOrPublicKey: process.env.JWT_SECRET_ACCESS_TOKEN as string,    });    //////    //trong refreshTokenValidator, ƒëo·∫°n    //const [decoded_refresh_token, refresh_token] = await Promise.all([    //  verifyToken({ token: value }),    //  databaseService.refreshTokens.findOne({ token: value })    //])    //ƒë·ªïi th√†nh    const [decoded_refresh_token, refresh_token] = await Promise.all([      verifyToken({        token: value,        secretOrPublicKey: process.env.JWT_SECRET_REFRESH_TOKEN as string,      }),      databaseService.refreshTokens.findOne({ token: value }),    ]);    ```- n·∫øu request login|logout thi·∫øu access_token hay refresh_token th√¨ ta s·∫Ω tr·∫£ v·ª? l·ªói 422(sai validator), ƒëi·ª?u n√†y m√¨nh kh√¥ng th√≠ch, v√¨ l·ªói thi·∫øu ƒë√≥ m√¨nh mu·ªën l√† 401: UnAuthorized  v·∫≠y n√™n m√¨nh s·∫Ω fix l·∫°i c√°c middlewares `accessTokenValidator` v√† `refreshTokenValidator`  ```ts  //ƒëo·∫°n c·ªßa accessTokenValidator, ta th√™m trim ƒë·ªÉ x√≥a kho·∫£ng c√°ch th·ª´a v√†  export const accessTokenValidator = validate(    checkSchema(      {        Authorization: {          trim: true, //th√™m          custom: {            options: async (value: string, { req }) => {              const access_token = (value || '').split(' ')[1]      ...  //ƒëo·∫°n c·ªßa refreshTokenValidator, ta th√™m trim ƒë·ªÉ x√≥a kho·∫£ng c√°ch th·ª´a v√†  export const refreshTokenValidator = validate(  checkSchema(    {      refresh_token: {        trim: true, //th√™m        custom: {          options: async (value: string, { req }) => {            if (!value) {              throw new ErrorWithStatus({                message: USERS_MESSAGES.REFRESH_TOKEN_IS_REQUIRED,                status: HTTP_STATUS.UNAUTHORIZED //401              })            }            try {              ...  ```- gi·ª? ta test l·∫°i postman 1 l·∫ßn# t·ªëi ∆∞u h√≥a postman- t·∫°o enviroment cho postman  ![Alt text](image-100.png)  ch·ª?n add- t·∫°o c√°c bi·∫øn  ![Alt text](image-101.png)- cho logout x√†i bi·∫øn lu√¥n  ![Alt text](image-103.png)  ![Alt text](image-104.png)- set access_token cho to√†n th∆∞ m·ª•c  folder>users>authorization>type>Bearer Token>  ![Alt text](image-105.png)  logout ch·ªâ c·∫ßn `inherit autho from parent`  ![Alt text](image-106.png)- t·ª± ƒë·ªông l∆∞u access v√† refresh token v√†o envi  - login ta th√™m script v√†o task `test`  ```js  pm.test("Login th√†nh c√¥ng", function () {    pm.response.to.have.status(200);    let responseJson = pm.response.json();    const { access_token, refresh_token } = responseJson.result;    pm.environment.set("access_token", access_token);    pm.environment.set("refresh_token", refresh_token);  });  ```- v√† test l·∫°i bth gi·ªØa login v√† logout